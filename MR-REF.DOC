
        *** PLEASE ALSO SEE READ.ME FOR FURTHER REFERENCE ***


             ========================================
             The general layout of a MoonRock program
             ========================================

--start of file--------------------------------------------
BEGIN DEF

  <def line(s)>      ' Special global compiler definitions

BEGIN CODE

  <code line(s)>     ' General code
----------------------------------------------end of file--


BEGIN DEF and BEGIN CODE are only required if you actually have extra
definitions. MoonRock will happily assemble source with only general
code, and no BEGIN lines.


                        ====================
                        Commands in DEF area
                        ====================

COMMON <var1> [, <var2> ... ]

  Specifies which variables are COMMON or global, that is, shared
  between subroutines and modules. By default a variable is unique to
  that sub. Use COMMON for global variables which need to be accessed
  from more than one sub or module.



LANGUAGE <lang>

  Defines the dependent language that this code will be called from.
  Currently the supported languages are:

     QUICKBASIC

  This setting is only relevant if the commandline /L is specified.

  See "Language dependent OBJ production" section for further
  information.


BUNDLE <name> <var1>, <var2> ...

  Defines a bundle. This is a similar to a C struct or QuickBASIC type,
  except a set memory space is preallocated. Arrays of bundles are
  currently not possible.

  Bundle members are listed in order and their relevant type. For string
  variables, MoonRock will convert to/from 2 popular field formats
  (Pascal and C), or its own internal format. To accomplish this,
  MoonRock needs to know how much space the string field occupies in the
  record; for example a variable length Pascal string will actually
  occupy a constant space on disk. A Pascal string of maximum length 9
  would be defined as:

       Str$[10] Pascal    ' This includes a byte for length of string

  Note that the maximum length includes any terminators or length
  bytes/words.

  The type of string needs to be specified, and can be one of the
  following:

       Pascal  (byte length+string)
       Null    (string+0)
       MR      (word length+string)

  In a Pascal string, the first byte defines the length of the string,
  and the string contents (if any) follow. Any bytes past the string
  length are ignored when read, and are undefined when written to disk.
  Maximum length of a string is 255 characters.

  In a null terminated C string, a null (0) character terminates the
  string. Any characters past the null are ignored on read and undefined
  on write. In a special exception, if the string fits the field
  exactly, the null terminator is not present.

  In a MoonRock string, the first two bytes (word) holds the length of
  the string, then the string contents (if any) follow. Any bytes past
  the string length are ignored on read, and are undefined when written.
  Maximum string length is 65535 bytes.

  A bundle definition must be on a single line, or, have a trailing "_"
  at the end of the line to tell MRC to join the next line to it.

  Some examples of bundle definitions:

  bundle PKTHeader  OrigNode%, DestNode%, Year%, Month%, day%,_
                    hour%, minute%, second%, Baud%, PKTType%,_
                    OrigNet%, DestNet%, ProdCode1%, PassWord$[8] Null,_
                    QOrigZone%, QDestZone%, AuxNet%, CWvalidation%,_
                    ProdCode2%, CW%, OrigZone%, DestZone%,_
                    OrigPoint%, DestPoint%, f1&

  bundle Ezy  PrevReply%, NextReply%,_
              StartPosi&, MsgLength&,_
              DestNet1&, DestNet2&,_
              OrigNet1&, OrigNet2&,_
              Cost%,_
              MsgAttr@, NetAttr@, ExtAttr@,_
              Post&, Rcvd&,_
              WhoTo$[36] Pascal,_
              WhoFrom$[36] Pascal,_
              Subject$[73] Pascal

  NOTE: Currently strings are only supported when reading bundles from
  disk. Attempts at writing bundles with strings will be successful, but
  will result in random junk characters being saved in place of the
  string.



TYPE <typename> <bundle definition>

  TYPE is a simple way to specify multiple bundle names which have
  exactly the same elements. It can also be used to allow preset include
  files to be shared between programs with bundles still having unique
  names that you can specify. An example is for the INT86 and INT86X
  functions.

  in regs.h (ie #include regs.h):
    type REGS86  AX%, BX%, CX%, DX%, BP%, SI%, DI%, FLAGS%
    type REGS86X AX%, BX%, CX%, DX%, BP%, SI%, DI%, FLAGS%, DS%, ES%

  in your program, DEF area:
    bundle reg REGS86     ' bundle reg
    bundle regX REGS86X   ' bundle regX

  in your program, CODE area:
    reg.AX% = 1FFh        ' use it like a normal bundle



STRSEGSIZE <val>

  This sets the size of the combined data/string segment, also known
  generally as "dynamic" or "near" memory. If no STRSEGSIZE command is
  present, a default of 32k is assumed. The maximum size that can be
  allocated is 64k.

  Examples:
       strsegsize 1000      ' specified in bytes
       strsegsize 48k       ' specified in K



STACK <val>

  Sets the size of the stack for the program. If no STACK command is
  present, a default of 1024 bytes is assumed. You would not normally
  use this command.

  Examples:
       stack 512
       stack 2k


SUB <name> [ <parm1> [ , <parm2> ... ] ]

  Defines a subroutine. This must be identical to the subroutine
  definition in the CODE area. The parameter list is optional. If any
  mismatches are found later in the code either when calling the sub, or
  in the sub itself, they will be reported as errors.

  If any pointers or strucs are specified in the parameter list, they
  must have been previously defined.

  Examples:
       sub PrintString (st$)
       sub KillFile (SourceDir$, FileName$, Flag%)
       sub OpenAndSeek (FileName$, Attrib%, Position&)
       sub MySubroutine



DIM [FAR | HUGE] <arrayname>'['<elements>']'

  Dimensions an array for use later in your program. Array types
  supported are word, doubleword, and string. Word and doubleword arrays
  can be dimensioned in FAR or HUGE memory if need be; this will move
  the array out of the communal 64k data segment into its own segment.
  Far arrays add slightly more code overhead every time they are
  accessed, so use the FAR option only if you need as much communal 64k
  as possible. If you need arrays of more than 65535 bytes, 32767 words,
  or 16383 doublewords then use the HUGE option as a last resort.

  Examples of dimensioning:
       dim a%[100]
       dim far myarray@[10000]
       dim myname$[5000]
       dim far lo&[20]
       dim huge bigarray&[100000]

  Arrays are referenced like so:
       a%[1]       ' constant element
       a%[aptr%]   ' variable element

  An array element may be used almost anywhere a normal variable can.

  Currently array size must be specified at compile time. If debugging
  code is included when compiling (/D switch) then array bounds checking
  will be performed to ensure that an illegal element is not accessed.



%CONSTANT

  Constants are defined in the DEF area, and may be referenced
  throughout the rest of the program. They can only be defined once, and
  they are global.

  The format of a constant definition is:

       '%'<ConstantName> = <value>

  Constants may also be evaluated with addition, subtraction,
  multiplication, and division. Only numerical values and other
  constants may be used. For example:

       %MyConstant = 2
       %AnotherConstant = %MyConstant + 3 * 2

  %AnotherConstant is now equal to 10.

  In the CODE area, constants may be used anywhere a normal numerical
  value would be.



SET

  SET is a method of creating a contiguous set of constants. The format
  is:

       set = <start>, '%'<const1>, '%'<const2> ...

  The value of <start> determines the starting value of the first
  constant; each constant is then defined to one higher than the
  previous constant. For example:

       set = 51, %ConstOne, %AnotherConst, %YetAnotherConst

  In the above example, %YetAnotherConst is defined as 53.



POINTER [BYTE | WORD | DWORD | STRING] [NEAR | FAR | HUGE] <varname>'~'

  Defines a pointer. A pointer is a low level device used to directly
  access memory. In MoonRock, this can either be NEAR memory (MoonRock's
  data segment -- default), FAR memory (any part of a far 64k segment)
  or HUGE memory (any memory location between 0-1023k conventional).

  The pointer size specifies the size of the memory location to
  access: it can either be BYTE, WORD, or DWORD.

  Examples:

       pointer word myptr~               ' defaults to NEAR type
       pointer byte far colour_screen~
       pointer dword huge mybigptr~
       pointer string strptr1~           ' all string pointers must
                                         ' be NEAR

  A pointer variable type has the '~' suffix.

  There are two types of pointer references. One where a pointer is
  directly assigned a value (told where to point to), and one where a
  pointer is used to retrieve or store data.

  A pointer should be assigned a value before use, otherwise results
  are unpredictable. Example:

       colour_screen~ = 0b8000000h  ' colour text screen resides at
                                    ' location b800:0000

  The pointer is now ready for use, and can be accessed just like a
  normal variable. A pointer *references* a memory location when it is
  enclosed in square brackets:

       [colour_screen~] = 65

  This places the value "65" into the location that [colour_screen~]
  points to (b800:0000h). In this case it would print the letter "A" in
  the top left hand corner of the colour text screen. If you were to do
  the following:

       a% = [colour_screen~]

  The value "65" would be placed into a%, since that is what we have
  just saved at [colour_screen~] (b800:0000h).

  Pointer definitions are global over the entire source file. A pointer
  cannot be redefined. Pointers may be added, subtracted, divided and
  multiplied just like normal numerical variables.

  Pointers are an advanced method of accessing memory, and as such a
  detailed explanation is beyond the scope of this section.



STRUC <strucname> [NEAR | FAR | HUGE] <var1> [,<var2> [,<var3> ... ] ]

  Strucs are similar in concept to pointers, except they are a much more
  powerful function that allow you to reference a complete set of
  variables rather than just a single fixed size location.

  Here are some examples:

    struc mystruc var1%, var2%
    struc hello far a@, b%, c&, d$

  Note that the structure name comes BEFORE the optional near/far/huge
  declaration.

  Strucs are referenced in a similar way to pointers, except the name of
  the structure element is also included:

    [hello~d$] = "hello"



#INCLUDE <filename>

  Includes specified <filename> as if it was part of the main source.
  Useful for constant definitions such as the MoonRock *.H header files,
  or code which is common over several programs.

  If a full path is specified, the file is searched for in the specified
  directory.
  If no path is specified, the current directory is searched, then the
  directory pointed to by the "MRINCLUDE" environment variable. From the
  DOS prompt, type:

       set mrinclude=c:\mr

  ... change the path to suit your system. Note that there is no
  trailing backslash.

  The #INCLUDE directive may also be used in the CODE area.



                =================================
                Language dependent OBJ production
                =================================

LANGUAGE DEPENDENT OBJ PRODUCTION IS NO LONGER SUPPORTED AND IT IS
STRONGLY RECOMMENDED YOU DO NOT USE THIS. THE DOCUMENTATION FOR THIS
FEATURE IS INCLUDED FOR COMPLETENESS.


NOTE: This is an experimental feature, and is sometimes prone to strange
behaviour if runtime errors occur while executing MoonRock code. Do not
use in release code!

MoonRock has the capability to interface directly to another language
which provides a "shell" for it. Currently only QuickBASIC is supported.
MoonRock functions cannot be called until they have been initialised by
a special function call.

In the BEGIN DEF area of your *MoonRock* source code, the following
command must be present:

LANGUAGE QuickBASIC

At the beginning of your *QuickBASIC* source code you must DECLARE the
MoonRock functions that you are going to call. One which must be
declared is "<source_name>_INIT". For example, if the name of the
MoonRock source file is HELLO.MOO, the QuickBASIC declaration would be:

DECLARE FUNCTION MoonRockInit% ALIAS "HELLO_INIT"

At the start of your QuickBASIC program you must call MoonRockInit% to
initialise the MoonRock startup code. This needs to be done only once.
MoonRockInit% returns -1 (success) or 0 (failure). Initialisation will
fail if there is insufficient memory for MoonRock to allocate its data
segment. If failure is returned, do not attempt to call any of the
MoonRock subroutines -- it is recommended that the "shell" program
aborts with an error in this case.

For each MoonRock SUB you have defined in your MoonRock source, you will
also need to define it in your QuickBASIC source. The QuickBASIC format
for defining functions and subs is "__<name>", for example MoonRock
function "WriteDisk%" would be:

DECLARE FUNCTION WriteDisk% ALIAS "__writedisk"

MoonRock Sub "PrepareScreen" would be:

DECLARE SUB PrepareScreen ALIAS "__preparescreen"

If any parameters are passed, they must be of the same type between both
MoonRock and QuickBASIC. If you are passing an integer (%) or long (&),
you must use the BYVAL keyword in your QuickBASIC source. For example,
if the MoonRock definition is:

Sub CreateDir (dirname$, attribute%)

Then the definition in your QuickBASIC source file is:

DECLARE SUB CreateDir (dirname$, BYVAL attribute%)

Also, your MoonRock function can return a numerical value back to
QuickBASIC. Use "return(value)" instead of just "return" at the end of
your sub, for example:

return     ' return 0
return(1)  ' return 1
return(a&) ' return value of a&

Finally, all code in "main" is ignored for a language dependent compile.



                            ==========
                            Inline ASM
                            ==========

Simply preface source your line (in the CODE area) with '@'. This will
be passed directly to the assembler, apart from MoonRock variable
references, which are converted as appropriate. No error checking on
assembly syntax is performed by MoonRock.

Variables may be referenced directly thus:

        @mov    ax,word ptr ds:[a%]  ; load value of MoonRock a% into AX
        @mov    si,word ptr ds:[s$]  ; load SI with pointer to MR s$

Note that comments must be prefaced with a ';' character.


                        ===================
                        MoonRock data types
                        ===================

Referenced as   Commonly known as           Notes
-------------   -------------------------   ------------------------------
@               BYTE                        Signed. Range -128 to +127
%               WORD or INTEGER             Signed. Range -32768 to +32767
&               DOUBLEWORD or LONG          Signed. Range -2147483648 to
                                                      +2147483647
$               STRING                      32767 characters max
^               BUNDLE or TYPE
~               POINTER or STRUC


                        ==================
                        MoonRock operators
                        ==================

=               Equal to
<>              Not equal to
>               Higher than
<               Lower than
>=              Higher than, or equal to
<=              Lower than, or equal to

+               Addition
-               Subtraction
*               Multiplication
/               Division (rounded)
\               Division (integer)


                  ===========================
                  Limitations of the compiler
                  ===========================

* The compiler itself is rather slow, due to it being compiled with Visual
  BASIC for DOS. A future version is being rewritten in native MoonRock
  with inline assembly.

* Multiple operations must be broken into discrete parts. For example,

        print left(ltrim(cmdline), 10)

  Is not valid. Instead this should be used:

        t$ = cmdline
        t$ = ltrim(cmdline)
        print left(t$, 10)

  A future version will be less restrictive in what it accepts, and more
  powerful with what it can parse.

* Total variable space is limited to a 64k segment, apart from far
  or huge numerical arrays. A future version will support far strings.

* Array size must be defined at compile time, and cannot be altered at
  runtime.

* Compile time type checking is not always performed correctly. For
  example in many cases you can specify a numerical variable where a
  string variable *should* be specified.


                         ===============
                         Troubleshooting
                         ===============

If a MoonRock program compiles but does not assemble correctly, follow
these troubleshooting steps.

    1. Compile with the '/-O' switch, to disable optimisations. Buggy
       code generation comes from the optimisations usually (until I
       notice and fix them)
    2. If the compiled code will still not assemble, check that you
       have correctly dimensioned all your arrays, that you have
       not mis-spelt any commands, that you have not confused
       variable types. Sometimes MoonRock will not report misnamed
       variables or keywords.
    3. Finally, note the error(s) reported by your assembler. If you are
       unable to resolve the error(s) by changing your source, or it
       appears to be a compiler programming error, then please contact
       the author, quoting the section(s) of code that the assembler is
       complaining about.


                  ===============================
                  Moonrock commands and functions
                  ===============================

Note: Keywords are shown in all upper case to aid readability. They may
      be of any case in the source code.

      Keywords are listed in 'chronological' order, that is, the order
      in which they were added to the documentation. Use MRHELP for an
      alphabetically sorted list.


      The conventions for parameters are:

              @   byte
              %   word
              &   doubleword
              $   string
              ~   pointer or struc
              ^   bundle
              <>  any other type of parameter

      Where more than one type of parameter can be used, they are
      joined, eg: "%&"

      A parameter of type @ or % or & or ~ may be a numerical constant

      A parameter of type $ may be a string constant

--------------------------------------------------------------------------

    command:      $OUTSTREAM
    use:          $OUTSTREAM <drivername>
    description:  Sets appropriate screen output driver.
    notes:        Drivers available are:
                    _tty_str_dos
                       Default. Uses DOS INT 21h/AH=40h for writes. Writes
                       are redirectable. Single colour only.
                    _tty_str_bios
                       Uses BIOS screen writes. Allows colour, cursor
                       positioning, and CLS command.
                    _tty_str_direct
                       Uses direct screen writes. Allows colour, cursor
                       positioning, CLS command, screensave/screenrestore
                       commands. This driver requests a virtual screen
                       shadow buffer if running under DESQview.
                  The driver cannot be set 'on the fly', it is constant
                  at compile time.

--------------------------------------------------------------------------

    command:      END SUB
                  RETURN
    use:          END SUB
                  RETURN [ (<value>) ]

    description:  Return from SUB.
    notes:        <value> is only valid for language dependent SUBs
                  (compiled with /L option).
    examples:
                  return
                  return(a%)   ' Return value of a% to calling language
    see also:     SUB
    important:    For normal MoonRock programs, END SUB should be used
                  in preference to RETURN, as RETURN will be used for a
                  different purpose in a future version of the compiler.
                  The current version of the compiler will report a
                  warning if RETURN is used.

--------------------------------------------------------------------------

    command:      FOR
                  TO
                  NEXT
    use:          FOR loop@%& = start@%& TO end%&
                  ...
                  NEXT
    description:  Software loop. <loop> is initially given the value of
                  <start>. All code between 'for' and 'next' is
                  executed; when 'next' is reached <loop> is
                  incremented. If <loop> is lower than <end> the loop
                  continues.
    example:
                  for i% = 10 to 20
                    print i%
                  next

--------------------------------------------------------------------------

    command:      IF
                  THEN
                  ELSE
                  ENDIF
    use:          IF <evaluation> THEN
                  ...
                  [ELSE]
                  ...
                  ENDIF
    description:  Conditional code execution. If <evaluation> is true,
                  then all code between 'then' and 'else' or 'endif' is
                  executed; otherwise code between 'else' and 'endif' is
                  executed, if 'else' is present.
    notes:        You may also include IF..THEN and the conditionally
                  executed code on the same line. Successive IF..THEN
                  statements may be "stacked" onto the same line.
                  The general form is: IF <evaluation> THEN (conditional code)
                  For this type of IF..THEN there is no ELSE or ENDIF
                  command.

    examples:
                  ' Example 1.
                  if a% = 2 then
                    print "a% is 2"
                  endif

                  ' Example 2.
                  if fexist("c:/command.com", 7) = TRUE then
                    handle% = fopen("c:/command.com")
                  else
                    print "COMMAND.COM not found -- aborting.\n"
                    end(1)
                  endif

                  ' Example 3.
                  if a% <> 2 then print "a% is not 2!"
                  if a% >= 2 then if a% <= 4 then print "a% between 2 and 4"

--------------------------------------------------------------------------

    command:      WHILE
                  WEND
    use:          WHILE <evaluation>
                  ...
                  WEND
    description:  Conditional code loop. While <evaluation> is true,
                  code between 'while' and 'wend' is executed.
    example:
                  while v& < 65000
                    v& = v& + 100
                  wend

--------------------------------------------------------------------------

    command:      END
    use:          END [(<returnvalue>)]
    description:  Ends execution and returns to DOS or calling program.
                  If <returnvalue> is specified then this will be the
                  errorlevel returned, otherwise errorlevel 0 will be
                  returned.
    examples:
                  end
                  end(1)   ' return errorlevel 1
                  end(a%)  ' return errorlevel of value of a%

--------------------------------------------------------------------------

    command:      PRINT
    use:          PRINT <String> [ + <String> ... ]
    description:  Print string to current output stream. <String> may be
                  a string constant (enclosed by double quotes), a
                  string function, a string variable, or a numeric
                  function.
    notes:        If a "\" character is present in a string constant
                  (enclosed by double quotes) then the following
                  character(s) are evaluated for special escape
                  sequences. Valid escape sequences are:

                    \n    Newline (ASCII 13, ASCII 10)
                    \g    BEL (ASCII 7 - beep)
                    \0    NUL (ASCII 0)
                    \r    Return character (ASCII 13)
                    \h..  Where '..' is a 2 digit hex number
                    \\    "\" character

                  To print the literal "\" character, use two in
                  sequence.
    examples:
                  print "Hello world!\n"
                  print "Current value is " + v% + ". Is this correct? "
                  print "Free far memory: " + freemem(2) + " bytes."

--------------------------------------------------------------------------

    command:      COLOUR
    use:          COLOUR foreground@%& [ , background@%& ]
    description:  Set both or either foreground or background text
                  colour.
    notes:        "?" may be used in place of either <foreground> or
                  <background> to denote no change in that field.
    examples:
                  colour 3
                  colour fground%, bground%
                  colour ?, bground%  ' do not change foreground colour
    comment:      Some people disagree with my spelling of 'colour'. I
                  just tell them that the USA is not the centre of the
                  universe -- RC

--------------------------------------------------------------------------

    command:      CALL
    use:          CALL <name> [ <parm1> [ , <parm2> ... ] ]
    description:  Calls a SUBroutine (must be previously defined).
    notes:        Parameters, if any, must be of the same type as the
                  previous definition of the SUB in the BEGIN DEF area.
                  A type mismatch error will result otherwise.
    example:
                  call WriteData (handle%, 1024, a$)

--------------------------------------------------------------------------

    command:      FCLOSE
    use:          FCLOSE (handle@%&)
    description:  Close a previously opened file. <handle> is the file
                  handle previously allocated when the file was opened.
    notes:        Do not attempt to close handles 1-4.
    example:
                  fclose (handle%)

--------------------------------------------------------------------------

    function:     FPUT
                  FGET
    use:          FPUT (handle@%&, value@%&$^)
                  value@%&$^ = FGET (handle@%&)
    description:  Get or put binary bytes to an open file.
    notes:        Size of data written or read depends on the variable
                  type passed:

                        Data type     Example   Bytes read or written
                        ---------     -------   ---------------------
                             byte     bb@       1
                     word/integer     fork%     2
                  doubleword/long     free&     4
                           string     hop$      length of string
                           bundle     mybund^   length of bundle

                  Internal DOS file handles 0-4 may be specified, but
                  take care when doing so.
    examples:
                  fput (out%, buf$)
                  fput (out%, Version@)
                  bund^ = fget (handle%)

--------------------------------------------------------------------------

    command:      FSEEK
    use:          FSEEK (handle@%&, position&)
    description:  Seek to specified <position> in open file.
    note:         The first byte of a file is at position 0.
    example:
                  fseek (h%, 1000)

--------------------------------------------------------------------------

    command:      FPRINT
    use:          FPRINT (handle@%&, <String> [ + <String> ... ])
    description:  Print string to open file. <String> may be a string
                  constant (enclosed by double quotes), a string
                  function, a string variable, or a numeric function.
    notes:        If a "\" character is present in a string constant
                  (enclosed by double quotes) then the following
                  character(s) are evaluated for special escape
                  sequences. Valid escape sequences are:

                    \n    Newline (ASCII 13, ASCII 10)
                    \g    BEL (ASCII 7 - beep)
                    \0    NUL (ASCII 0)
                    \r    Return character (ASCII 13)
                    \h..  Where '..' is a 2 digit hex number
                    \\    "\" character

                  To print the literal "\" character, use two in
                  sequence.

                  The entire line is evaluated before writing to the
                  file, rather than writing each element discretely as
                  with print.
    examples:
                  fprint(h%, "Hello, this file has a handle of " + h%)
                  fprint(out%, "---------  " + day + ", " + date)

--------------------------------------------------------------------------

    command:      INPUT
    use:          INPUT (string$ [, len@%& [, <fill> ] ] )
    description:  Input a string from the keyboard.
    notes:        Optional parameter <len> specifies the maximum length
                  of the field to input. If this is not specified then
                  the default length is 78.
                  Optional parameter <fill> specifies the fill character
                  to use to fill the input field, in ASCII (numerical)
                  format. Some examples:

                  Character    ASCII value
                  ---------    -----------
                  .            46
                  ±            177
                  ú            250

                  The input command only supports strings. To input a
                  number, use something like:

                    input (tmpstr$)
                    number% = val(tmpstr$)
    examples:
                  input (s$)
                  input (s$, 20, 177)

--------------------------------------------------------------------------

    function:     HEX8
    use:          HEX8 (value@%&)
    description:  Print <value> as a hexadecimal 8 bit number.
    notes:        Value is padded to 2 digits with leading "0"
                  characters if necessary.
    example:
                  print "Hex value is " + hex8(h@) + "\n"

--------------------------------------------------------------------------

    function:     HEX16
    use:          HEX16 (value@%&)
    description:  Print <value> as a hexadecimal 16 bit number.
    notes:        Value is padded to 4 digits with leading "0"
                  characters if necessary.

--------------------------------------------------------------------------

    function:     HEX32
    use:          HEX32 (value@%&)
    description:  Print <value> as a hexadecimal 32 bit number.
    notes:        Value is padded to 8 digits with leading "0"
                  characters if necessary.

--------------------------------------------------------------------------

    function:     UCASE
                  LCASE
    use:          UCASE (str$)
                  LCASE (str$)
    description:  Converts a string to all upper or all lower case.
    example:
                  cmd$ = lcase(cmd$)

--------------------------------------------------------------------------

    function:     LTRIM
                  RTRIM
    use:          LTRIM (str$)
                  RTRIM (str$)
    description:  Trim string of whitespace (characters below and
                  including the space character " " ASCII 32) on either
                  the right or left hand side.
    example:
                  cmd$ = ltrim(cmd$)

--------------------------------------------------------------------------

    function:     INKEY
    use:          INKEY
    description:  Returns a keypress as an integer value. Does NOT wait for
                  input.
    notes:        If there is no keypress currently available then a
                  value of -1 will be returned.
    example:
                  k% = -1
                  while k% = -1
                    k% = inkey
                  wend

--------------------------------------------------------------------------

    function:     AND
                  OR
                  XOR
    use:          AND
                  OR
                  XOR
    description:  Bitwise operations.

                  AND      Bit1   Bit2       Result
                           ----   ----       ------
                              0      0            0
                              0      1            0
                              1      0            0
                              1      1            1

                  OR       Bit1   Bit2       Result
                           ----   ----       ------
                              0      0            0
                              0      1            1
                              1      0            1
                              1      1            1

                  XOR      Bit1   Bit2       Result
                           ----   ----       ------
                              0      0            0
                              0      1            1
                              1      0            1
                              1      1            0
    example:
                  a% = b% xor 2 or v% and 0ffh

--------------------------------------------------------------------------

    function:     SHR
                  SHL
    use:          SHR value@%&
                  SHL value@%&
    description:  Bitwise shift left or right by <value> times.
    example:
                  v% = b% shr 5

--------------------------------------------------------------------------

    function:     FREEMEM
    use:          FREEMEM (<number>)
    description:  Returns size of available memory.
    notes:        The following values are valid for <number>:

                  Value     Returned
                  --------  --------
                  0         Total free near memory (64k max)
                  1         Largest free near memory block
                  2         Total free far memory (doubleword)

                  Under DPMI the value returned for "Total free far
                  memory" will be the amount of free memory that DPMI
                  reports.
    examples:
                  print "Total free near memory:    " + freemem(0)
                  print "Largest near memory block: " + freemem(1)
                  print "Total free far memory:     " + freemem(2)

--------------------------------------------------------------------------

    function:     LEN
    use:          LEN (str$)
    description:  Returns the length of given string.
    example:
                  l1% = len (in$)

--------------------------------------------------------------------------

    function:     TIMERTICK
    use:          TIMERTICK
    description:  Returns the number of ticks since midnight. There are
                  approximately 18 ticks per second.
    notes:        This can be used as a counter for scheduling periodic
                  events.
                  Returned precision is doubleword so you should use a
                  doubleword/long variable to store the value in.
    example:
                  ti& = timertick

--------------------------------------------------------------------------

    constant:     TRUE
    value:        -1

--------------------------------------------------------------------------

    constant:     FALSE
    value:        0

--------------------------------------------------------------------------

    command:      FCREATE
    use:          variable@%& = FCREATE (filename$ [ , <attr> ...] )
    description:  Creates a new file and returns a handle.
    notes:        If the file exists, it will be truncated to 0 bytes.
                  Valid attributes are:

                  readonly    File cannot be modified or deleted
                  hidden      File is hidden from normal DIR listing
                  system      File has system attribute set
                  archive     File has archive attribute set
                  shareable   File is shareable under NetWare

                  IMPORTANT! The ARCHIVE attribute should be included
                  with all FCREATE statements except for specialised
                  applications.
    examples:
                  h% = fcreate("MRC.ASM", archive)
                  tmphandle% = fcreate("C:/TEMP/TMPFILE.$$$", hidden)

--------------------------------------------------------------------------

    command:      FOPEN
    use:          variable@%& = FOPEN (filename$ [ , <mode> ... ])
    description:  Opens an existing file and returns a handle.
    notes:        Valid file modes are:

                  readonly    Read from file only. Ignore writes
                  writeonly   Write to file only. Ignore reads
                  readwrite   Allow both reads and writes

                  denynone    Sharing: allow all other tasks access
                  denyall     Sharing: deny all other tasks all access
                  denywrite   Sharing: deny writing for this file,
                                       to other tasks
                  denyread    Sharing: deny reading for this file,
                                       to other tasks

                  Default file mode is READWRITE and DENYNONE.

                  If the file does not exist, and fopen is invoked with
                  either WRITEONLY or READWRITE, then a new file will be
                  created; otherwise a "File not found" runtime error
                  results.

                  If locking modes are specified and SHARE.EXE or its
                  equivalent is not loaded, a runtime error may result.
    examples:
                  in% = fopen("MRC.CFG", readonly, denynone)
                  tmpfile% = fopen("C:/TEMP/TMPFILE.$$$",writeonly,denyall)

--------------------------------------------------------------------------

    function:     FPOS
    use:          variable& = FPOS (handle@%&)
    descripton:   Returns current file pointer in open file.
    notes:        The first byte in a file is at position 0.
    example:
                  posi& = fpos(inhandle%)

--------------------------------------------------------------------------

    function:     FNAME
    use:          variable$ = FNAME (handle@%&)
    description:  Returns the corresponding filename of the given
                  handle.
    notes:        The filename returned is exactly the same as the one
                  used to initially open the file.
    example:
                  f$ = fname(out%)

--------------------------------------------------------------------------

    function:     EXEC
    use:          variable@%& = EXEC (progname$, arguments$)
    description:  Executes another program, returning to the MoonRock
                  program afterwards.
                  The errorlevel of the called program is returned and
                  stored in <variable>.
    notes:        When specifying paths, MoonRock may get backslash '\'
                  characters confused with escape sequences. To avoid
                  this, use two backslash characters in sequence.
                  If the program to be executed is stored in a variable
                  (perhap user entered), it is a good idea to use
                  FTRUENAME to expand the filespec to a full path.
    example:
                  result% = exec ("C:\\DOS\\PKZIP.EXE", "-?")

--------------------------------------------------------------------------

    function:     FINDFIRST
                  FINDNEXT
    use:          FINDFIRST (filespec$, attr@%&)
                  FINDNEXT
    description:  Return filenames matching given filespec. Findfirst is
                  called, and then findnext should be called until no
                  more files are returned. A null string will be
                  returned if no matching files are found.
    notes:
                  <attr> is a value formed from the following:

                  hex  bit  meaning
                  ---  ---  -------------------------------
                  01h   0   Read only
                  02h   1   Hidden
                  04h   2   System
                  08h   3   Volume label
                  10h   4   Directory
                  20h   5   Archive
                  40h   6     --
                  80h   7   File is shareable under NetWare

                  Some operating systems such as NetWare are unable to
                  "clear" previous findfirst tables until all matching
                  files have been returned; eventually the number of
                  available tables will be exhausted. It is a good idea
                  to use findnext until no more matching files are
                  returned, to circumvent this potential problem.

                  The following extra information is available:

                      FFBLK.Attr@   ' File attribute
                      FFBLK.Time%   ' File time (DOS format)
                      FFBLK.Date%   ' File date (DOS format)
                      FFBLK.Size&   ' File size
                      FFBLK.Name$   ' File name

                  IMPORTANT: you must #include the file ffblk.h in the
                  BEGIN DEF area when using these functions.
    example:
                  filename$ = findfirst("C:/*.*", 7)
                  while filename$ <> ""
                    print filename$ + "\n"
                    filename$ = findnext
                  wend

--------------------------------------------------------------------------

    function:     MGET
    use:          variable@%& = MGET (offset% [ , segment%] )
    description:  Copy data from memory into a variable.
    notes:        Size of data read depends on the variable type passed:

                        Data type     Example   Bytes read
                        ---------     -------   ----------
                     word/integer     fork%     2
                  doubleword/long     free&     4
                           string     hop$      length of string

                  If optional <segment> is specified then data will be
                  pulled from that segment; otherwise the MoonRock data
                  segment will be used.
     examples:
                  a% = mget(offset%) ' value of MR data seg is assumed here
                  i& = mget(offset%, farseg%)

--------------------------------------------------------------------------

    function:     CMDLINE
    use:          variable$ = CMDLINE
    description:  Return parameters passed to your program on the DOS
                  commandline.
    notes:        See CMD.MOO for sample usage.
    example:
                  cmd$ = cmdline

--------------------------------------------------------------------------

    function:     CRC16
    use:          variable$ = CRC16(str$)
    description:  Returns 16 bit Cyclic Reduncancy Check (CRC) of
                  string.
    notes:        CRCs are useful for detecting data corruption or
                  change.
                  See also hash1() and hash2() functions.
    example:
                  crcval% = crc16(buf$)

--------------------------------------------------------------------------

    function:     FARMALLOC
    use:          variable% = FARMALLOC (size%)
    description:  Allocates a far memory segment.
    notes:        <size> can be anywhere between 1-65535 bytes. The
                  amount actually allocated will be rounded up to the
                  nearest paragraph (multiple of 16).
    example:
                  mysegment% = FARMALLOC (1024)  ' allocate 1024 bytes

--------------------------------------------------------------------------

    command:      FARMEMFREE
    use:          FARMEMFREE (pointer%)
    description:  Frees previously allocated far memory.
    notes:        DOS will free all allocated memory at the termination
                  of your program, so you are not required to free
                  everything before terminating. However, some DPMI
                  implementations do not appear to free allocated memory
                  when the process terminates.
    example:
                  farmemfree(ptr1%)

--------------------------------------------------------------------------

    function:     DATE
                  DAY
                  TIME
    use:          DATE
                  DAY
                  TIME
    description:  Return the current date, day name, or time.
    notes:        Date is returned in dd-Mmm-yyyy format (eg: "12-Jul-1995")
                  Day is returned in Ddd format (eg: "Sun")
                  Time is returned in hh:mm:ss 24 hour format.

                  The following extra information is available when the
                  DATE function is used:

                      DATEBLK.Day@
                      DATEBLK.Month@
                      DATEBLK.Year%

                  The following extra information is available when the
                  TIME function is used:

                      TIMEBLK.Hour@
                      TIMEBLK.Minute@
                      TIMEBLK.Second@
                      TIMEBLK.Sec100@  (1/100 seconds)

                  Note: The contents of the above variables are
                  undefined if the functions have not been used.

                  IMPORTANT: you must #include the file datetime.h in
                  the BEGIN DEF area when using these functions.

    example:
                  print "Today is " + day + " " + date + ", " + time

--------------------------------------------------------------------------

    function:     REPSTR
    use:          REPSTR(str$, count@%&)
    description:  Makes <count> copies of <str>.
    example:
                  a$ = repstr ("Hello ", 5)
                  ' Produces "Hello Hello Hello Hello Hello "

--------------------------------------------------------------------------

    function:     SINSTR
    use:          variable@%& = SINSTR(str$, set$)
    description:  Finds first occurrence of any of the characters in <set>,
                  in <str>.
    notes:        See CMD.MOO for practical sample implementation.
    example:
                  firstparm% = sinstr(cmd$, " ,:;/")
                  print left(cmd$, firstparm%)

--------------------------------------------------------------------------

    command:      FKILL
    use:          FKILL (filename$)
    description:  Deletes (unlinks) specified filename.
    example:
                  fkill ("foobar.bak")

--------------------------------------------------------------------------

    function:     SPACE
                  NULL
    use:          SPACE(count@%&)
                  NULL(count@%&)
    description:  Generate string of <count> spaces (ASCII 32) or nulls
                  (ASCII 0).
    examples:
                  a$ = null(20)
                  c$ = f$ + space(10)

--------------------------------------------------------------------------

    function:     STR
    use:          STR(value@%&)
    description:  Convert from numerical format to string format.
    examples:
                  s$ = str(val1%)
                  a$ = "Value is " + str(v&)

--------------------------------------------------------------------------

    function:     SBYTE
                  SWORD
                  SDWORD
    use:
                  variable@ = SBYTE (str$, position@%&)
                  variable% = SWORD (str$, position@%&)
                  variable& = SDWORD (str$, position@%&)
    description:  Gets a byte, word, or doubleword from a string.
    notes:        This is not the same as the val() function. This takes
                  a literal byte, word or doubleword from the string
                  memory.
    examples:
                  c% = sbyte(cmd$, 1)  ' asc(left(cmd$, 1))
                  c% = sword(a$, ptr%)

--------------------------------------------------------------------------

    function:     FEXIST
    use:          FEXIST (filespec$, fileattr@%&)
    description:  Check of the existence of one or more files.
    notes:        See FINDFIRST/FINDNEXT for list of valid file
                  attributes.
                  <filespec> may either be a filename or partial file
                  specification with wildcards.
                  TRUE is returned if at least one match is found.
                  FALSE is returned if no matches are found.
                  fexist is NetWare friendly and will correctly clear
                  outstanding NCP tables.
                  IMPORTANT: you must #include the file ffblk.h in the
                  BEGIN DEF area when using this functions.
    example:
                  if fexist("mrc.cfg", 7) = TRUE then
                    handle% = fopen("mrc.cfg")
                  endif

--------------------------------------------------------------------------

    function:     ASC
    use:          ASC (str$)
    description:  Return the ASCII value of first character of string.
    example:
                  a$ = "Hello"
                  a% = asc(a$)  ' a% = 72 ('H') now

--------------------------------------------------------------------------

    function:     VAL
    use:          VAL (str$)
    description:  Converts string to numerical variable.
    example:
                  a% = val(number$)

--------------------------------------------------------------------------

    function:     FTRUENAME
    use:          FTRUENAME(partial_filespec$)
    description:  Returns full path + filename of a partial file
                  specification.
    notes:        Can be used to determine full pathname when only
                  partial information is available. Known as
                  canonicalization.
    example:
                  a$ = ftruename("mrc.exe")

--------------------------------------------------------------------------

    function:     INSTR
    use:          variable@%& = INSTR (str1$, str2$)
    description:  Finds first occurrence of <str2> within <str1>.
    notes:        Returns 0 if no match found.
                  Returns 0 if <str1> is empty.
                  Returns 1 if <str2> is empty.
    example:
                  tmp$ = "Hi there. How are you today?"
                  c% = instr(tmp$, "are")    ' c% = 15

--------------------------------------------------------------------------

    function:     MID
    use:          MID(str$, position@%& [ , length@%& ] )
    description:  Return middle or rest of a string.
    notes:        If optional parameter <length> is omitted then the
                  rest of the string starting from <position> is
                  returned; otherwise only <length> characters are
                  returned, or the rest of the string, whichever is
                  less.
    examples:
                  print mid(a$, 10, 2)  ' Start from position 10,
                                        ' return 2 characters

                  print mid(a$, 10)     ' Start from position 10,
                                        ' return rest of string

--------------------------------------------------------------------------

    function:     LEFT
    use:          LEFT(str$, length@%&)
    description:  Returns left part of string.
    example:
                  b$ = left(a$, 10)     ' Return left 10 characters of a$

--------------------------------------------------------------------------

    command:      CLS
    use:          CLS
    description:  Clears the screen.
    notes:        Only available when _tty_str_bios or _tty_str_direct
                  are selected as screen drivers.

--------------------------------------------------------------------------

    command:      MCURSOR
    use:          MCURSOR (x@%&, y@%&)
    description:  Positions cursor at location x, y.
    notes:        Note that the screen grid is 0-based, that is the
                  upper left hand corner is 0,0. The co-ordinates are
                  specified in X,Y (column, row) format.
                  This command is only available when _tty_str_bios or
                  _tty_str_direct are selected as screen drivers.

--------------------------------------------------------------------------

    command:      FARMEMRESIZE
    use:          FARMEMRESIZE (segment%, size%)
    description:  Resize existing far memory block.
    notes:        This function returns a segment pointer which may
                  differ from the original segment passed. If DOS cannot
                  successfully resize the existing block, MoonRock will
                  create a new block and will copy data to that block,
                  and release the old block. Your program should be
                  prepared for the possibility of a different segment
                  being returned.
                  <Size> may be between 1-65535 bytes.
    example:
                  farmemresize(useg%, 65200)

--------------------------------------------------------------------------

    command:      TIMESLICE
    use:          TIMESLICE
    description:  Relinquish current time slice.
    notes:        This command is useful when running under
                  multitaskers. If DESQview is detected, then DV
                  timeslicing will be performed; if Windows/OS2
                  "generic" timeslicing is detected, then that will be
                  performed; otherwise DOS INT 28h "idle" interrupt will
                  be called.
                  The correct form of timeslicing is determined by
                  MoonRock during runtime initialisation.
                  This command should be used in loops where your
                  program is otherwise doing very little work, such as
                  waiting for a keypress.
    example:
                  k% = inkey
                  while k% = -1     ' No key pressed
                    timeslice       ' Give up time slice
                    k% = inkey
                  wend

--------------------------------------------------------------------------

    function:     CHR
    use:          CHR (value@%&)
    description:  Creates a string with the character <value> in it.
    example:
                  a% = 65
                  a$ = chr(a%)   ' a$ now contains "A"

--------------------------------------------------------------------------

    function:     HASH1
                  HASH2
    use:          variable@%& = HASH1 (str$)
                  variable@%& = HASH2 (str$)
    description:  Produces a "unique" 2 byte value from any length
                  string. Can be used for manipulating large amounts of
                  data quickly by use of hash tables.
    notes:        hash1 and hash2 differ slightly in the algorithm used
                  and will return totally different results. Use both
                  for extra security against "hash clash".
    example:
                  a% = hash1(a$)

--------------------------------------------------------------------------

    function:     CODESEG
                  DATASEG
    use:          CODESEG
                  DATASEG
    description:  Returns current code segment or data segment,
                  depending on function used.
    notes:        These functions replace the pseudovariables "codeseg%"
                  and "dataseg%" used in previous versions of MoonRock.
                  Code segment (CS) the is segment of currently executing
                  code.
                  Data segment (DS) is MoonRock's data segment.

--------------------------------------------------------------------------

    function:     RAND
    use:          RAND (range%)
    description:  Returns random number between 1 and <range>
    notes:        RAND() will return an identical sequence of numbers at
                  each execution of your program, unless the random
                  number generator has been seeded with RANDOMIZE().
                  <range> may be between 2 and 32767 for positive
                  values returned.
                  This function does not work well for low values of
                  <range>. It is better to use a large number for
                  <range> and scale (divide) the result.
    examples:
                  a% = rand(10000)       ' number between 1 and 10,000
                  co% = rand(100) / 10   ' number between 1 and 10.

--------------------------------------------------------------------------

    function:     FLEN
    use:          variable& = FLEN (handle@%&)
    description:  Returns length of open file.
    notes:        Use of a doubleword/long for <variable> is recommended
                  unless you have prior knowledge that the file will be
                  less than 32767 bytes in size.
    example:
                  s& = flen(handle%)

--------------------------------------------------------------------------

    function:     IS386
    use:          IS386
    description:  Checks for presence of a 386 or better processor.
    notes:        Returns TRUE (-1) if the processor is a 386 or better;
                  returns FALSE (0) if not.
                  This replaces the pseudovariable "is386%" which was
                  used in previous versions of MoonRock.
                  This function should be used with source that will be
                  compiled with the /3 (386+ code generation) option to
                  abort if the processor is not capable of 386+
                  instructions.
    example:

                  if is386 then
                    print "You have a 386 or better; you're elite."
                  else
                    print "This program only works on 386+ processors."
                    end(1)
                  endif

--------------------------------------------------------------------------

    function:     RIGHT
    use:          RIGHT(str$, length%)
    description:  Returns right part of string.
    example:
                  b$ = right(a$, 10)    ' Return right 10 characters of a$

--------------------------------------------------------------------------

    function:     FOSINIT
    use:          FOSINIT (comport@%&)
    description:  Initialise FOSSIL. Returns FOSSIL ID string for
                  successful initialisation, or null "" string if
                  failed.
    notes:        FOSSIL may be initialised for "local" use if the
                  comport specified is -1, any MoonRock FOSSIL functions
                  called thereafter will be ignored.
    example:
                  fosid$ = fosinit(1)

--------------------------------------------------------------------------

    command:      FOSDEINIT
    use:          FOSDEINIT
    description:  De-initialise FOSSIL. Performs orderly cleanup and
                  shutdown of the communications port. Should be used
                  when operations on the communications port are
                  complete.
    notes:        This command is ignored if the FOSSIL was initialised
                  to a "local" comport.

--------------------------------------------------------------------------

    command:      FOSTX
    use:          FOSTX(str$)
    description:  Transmit string to output.
    notes:        If the output buffer is full, this function waits
                  until it empties before returning; while waiting
                  timeslices are relinquished (see "timeslice" command)
                  This command is ignored if the FOSSIL was initialised
                  to "local" comport.
    example:
                  fostx("This is a string")

--------------------------------------------------------------------------

    command:      FOSFLUSH
    use:          FOSFLUSH
    description:  Flush output buffer
    notes:        Flushes the serial output buffer. Any data still
                  waiting to be transmitted is discarded.
                  This command is ignored if the FOSSIL was initialised
                  to "local" comport.

--------------------------------------------------------------------------

    function:     FOSCARRIER
    use:          FOSCARRIER
    description:  Check for presence of carrier detect (CD)
    notes:        Returns TRUE (-1) if carrier is present, FALSE (0) if
                  not.
                  Returns TRUE (-1) if the FOSSIL was initialised to a
                  "local" comport.
    example:
                  if foscarrier = FALSE then print "Carrier lost!"

--------------------------------------------------------------------------

    function:     FOSDATAWAITING
    use:          FOSDATAWAITING
    description:  Check for presence of data in the serial input buffer.
    notes:        Returns TRUE (-1) if data is present, otherwise
                  returns FALSE (0).
                  Returns FALSE (0) if the FOSSIL was initialised to a
                  "local" comport.
    example:
                  if datawaiting = TRUE then k% = fosgetchar

--------------------------------------------------------------------------

    function:     FOSGETCHAR
    use:          FOSGETCHAR
    description:  Get character from serial port without waiting.
    notes:        Returns -1 if no character is available.
                  Returns -1 if the FOSSIL was initialised to a "local"
                  comport.

--------------------------------------------------------------------------

    command:      FLOCK
                  FUNLOCK
    use:          FLOCK (handle@%&, start&, length&)
                  FUNLOCK (handle@%&, start&, length&)
    description:  Locks or unlocks a file; denies or grants access to
                  other processes accessing the file.
    notes:        SHARE.EXE or equivalent support must be loaded.
                  <start> specifies the start of the region you wish to
                  lock or unlock; length specifies the length.
                  To lock or unlock the entire file, use the following:

                    flock(handle%, 0, 0FFFFFFFFh)
                    funlock(handle%, 0, 0FFFFFFFFh)

                  Where handle% is the handle of the file you wish to
                  lock or unlock.
                  An unlock start/region must match exactly the original
                  lock start/region.
    example:
                  See LOCK.MOO for sample implementation.

--------------------------------------------------------------------------

    command:      DELAY
    use:          DELAY (ticks@%&)
    description:  Delays specified number of clock 'ticks'
    notes:        This delay is processor/speed independent and should
                  be used in preference to software loops.
                  Whilst in the delay loop, timeslices are relinquished
                  (see "timeslice" command).
                  There are approximately 18.2 ticks per second.
                  The maximum number of ticks that can be specified is
                  65535, which is approximately 60 minutes.
    example:
                  print "Now delaying 2 seconds..."
                  delay(36)    ' Approx 2 seconds
                  print "complete.\n"

--------------------------------------------------------------------------

    command:      FINPUT
                  FINPUTRAW
    use:          FINPUT (handle@%&, str$)
                  FINPUTRAW (handle@%&, str$)
    description:  Inputs a text line from an open file.
    notes:        With FINPUT, every character below ASCII 32 is
                  ignored, except TABs. With FINPUTRAW, only line feeds
                  (LF) are ignored.
    example:
                  finput(handle%, l$)
                  print "The line is: " + l$

--------------------------------------------------------------------------

    function:     MYPATH
    use:          MYPATH
    description:  Returns path of the currently executing program.
    notes:        This can be used to find configuration files if the
                  program was not executed from the current directory.
                  It is recommended that the value returned from MYPATH
                  be canonicalized (expanded to full path) with the
                  FTRUENAME function.
    example:
                  a$ = mypath   ' a$ now contains something like
                                ' "C:\MR\MYPATH.COM"

--------------------------------------------------------------------------

    function:     GETENV
    use:          GETENV(name$)
    description:  Returns the contents of the environment variable <name>.
    notes:        A null string is returned if the environment variable
                  is not found.
                  The name of the variable is not case sensitive.
    example:
                  print getenv("PATH")

--------------------------------------------------------------------------

    function:     NEG
    use:          NEG(var@%&)
    description:  Negate (two's complement) a number.
    example:
                  a% = 2
                  print neg(a%)    ' prints -2

--------------------------------------------------------------------------

    function:     STRCCNT
    use:          STRCCNT(str$, end@%&, character@%&)
    description:  Counts occurrences of character within a string.
    notes:        <end> is the position pointer to scan TO in the
                  string. If <end> is 0, then the entire string is
                  scanned.
                  <character> is specified in decimal ASCII form, eg a
                  space is 32.
    example:
                  s$ = "ABCDEFGABCDEFGABCDEFGABCDEFG"  ' A=ASCII 65
                  a% = strccnt(s$, 0, 65)              ' a% = 4

--------------------------------------------------------------------------

    function:     CINSTR
    use:          CINSTR(str$, character@%&)
    description:  Finds the first occurrence of character in a string.
    notes:        <character> is specified in decimal ASCII form, eg: a
                  space is 32.
                  This is significantly faster than using instr() if you
                  only need to search for a single character.
    example:
                  s$ = "ABCDEFG"       ' B=ASCII 66
                  a% = cinstr(s$, 66)  ' a% = 2

--------------------------------------------------------------------------

    function:     HUGEMALLOC
    use:          HUGEMALLOC(size&)
    description:  Allocates far memory of more than 64k.
    notes:        <size> may be a numerical constant or variable.
                  Returns a segment (word) value, except when used with
                  a FAR or HUGE pointer.
                  Memory allocated with HUGEMALLOC can be freed with
                  FARMEMFREE.
    example:
                  myseg% = hugemalloc(400000)  ' allocate 400,000 bytes

--------------------------------------------------------------------------

    function:     VARPTR
    use:          VARPTR(var@%&$^~)
    description:  Returns the offset of a variable.
    notes:        Useful for manipulation with pointers, equivalent to
                  the "offset" ASM keyword.
                  For numerical variables, varptr points directly to the
                  location which holds the value; for string, it is a
                  pointer to a pointer. In both cases, the value
                  returned by varptr will remain constant throughout
                  program execution.

--------------------------------------------------------------------------

    function:     STRPTR
    use:          STRPTR(str$)
    description:  Returns the address (offset) of string variable
                  contents.
    notes:        This returns a pointer to the actual string contents.
                  MoonRock strings are stored with a leading word size,
                  then the string itself.
                  While the value of varptr remains constant, strptr
                  will change as the string is modified.

--------------------------------------------------------------------------

    command:      SOUNDON
    use:          SOUNDON(frequency@%&)
    description:  Turns on the PC speaker and produces an audible sound.
    notes:        <frequency> is the frequency measured in Hertz (Hz).
                  soundoff must be used to turn off the sound.
    example:
                  soundon(440)   ' 440Hz
                  delay(18)      ' pause 1 second
                  soundoff       ' stop sound

--------------------------------------------------------------------------

    command:      SOUNDOFF
    use:          SOUNDOFF
    description:  Turns off the PC speaker after prior soundon command.

--------------------------------------------------------------------------

    function:     SGN
    use:          SGN(variable@%&)
    description:  Returns the sign of a numerical variable.
                  If the variable is negative, then -1 is returned.
                  If the variable is zero, then 0 is returned.
                  If the variable is positive, then 1 is returned.

--------------------------------------------------------------------------

    command:      ATEXIT
    use:          ATEXIT(<subname>)
    description:  Adds a SUB to call when the program is terminated.
    notes:        This is handy for cleanup routines at the termination
                  of a program, for example, restoring of interrupt
                  vectors.
                  Up to 16 SUBs may be called at exit.
                  The subroutines are called directly after a
                  terminating END command, *or* after a runtime error
                  occurs.
                  If a runtime error occurs within a SUB that is called
                  at exit, then the program will be aborted immediately
                  with the error message:

                  "Program error: exception occurred in _atexit"

                  Care should be taken to try to avoid runtime errors in
                  these SUBs.

--------------------------------------------------------------------------

    command:      PUSH
                  POP
    use:          PUSH variable@%&$^~
                  POP variable@%&$^~
    description:  Pushes (saves) or pops (restores) a variable to or
                  from the stack.
    notes:        These commands use the processor stack, which must be
                  shared with the MoonRock program executing, and
                  interrupt service routines. In some cases it may be
                  necessary to use the STACK directive in the BEGIN DEF
                  area to increase the allocated stack.
                  The number of pushes and pops must be the same, and
                  they must be in LIFO (Last In, First Out) order.
                  Use these with care. Failure to correctly balance the
                  stack may result in program or system crash.
    example:
                  ' This example saves two variables to the stack,
                  ' changes them, then restores them from the stack.
                  a% = 10
                  b% = 50
                  push a%  ' save a%
                  push b%  ' save b%
                  a% = 0   ' zero a%
                  b% = 0   ' zero b%
                  pop b%   ' restore b% -- note LIFO order
                  pop a%   ' restore a%
                  print "a% = " + a% + "\nb% = " + b%

--------------------------------------------------------------------------

    command:      SWAP
    use:          SWAP variable1@%&$^~, variable2@%&$^~
    description:  Directly swaps two variables in memory.
    notes:        A functional diagram of swap is:
                    var1 -> temp
                    var2 -> var1
                    temp -> var2
                  Using swap instead of discrete code is marginally
                  faster for numerical variables, and significantly
                  faster for string variables.

--------------------------------------------------------------------------

    command:      CPUT
    use:          CPUT (xpos@%&, ypos@%&, character@%&)
    description:  Writes specified character directly to the screen at
                  co-ordinates <xpos> and <ypos>.
    notes:        <character> is a number ranging from 0-255.
                  This command is only available with the
                  _tty_str_direct screen driver.
                  When compiled with debugging (/D) option, range
                  checking will be performed. If CPUT is passed a
                  co-ordinate which is off the screen, an invalid
                  function call error (#6) results.
    example:
                  cput(0, 0, 33) ' prints '!' in top left-hand corner

--------------------------------------------------------------------------

    function:     CGET
    use:          CGET (xpos@%&, ypos@%&)
    description:  Returns character and attribute at co-ordinates <xpos>
                  and <ypos>.
    notes:        The attribute is returned in the higher 8 bits; the
                  character is returned in the lower 8 bits.
                  For character only, use:
                    tmp% = cget(x%, y%)
                    tmp% = tmp% and 0FFh  ' tmp% contains character
                  For attribute only, use:
                    tmp% = cget(x%, y%)
                    tmp% = tmp% shr 8     ' tmp% contains attribute
                  This function is only available with the
                  _tty_str_direct screen driver.
                  When compiled with debugging (/D) option, range
                  checking will be performed. If CGET is passed a
                  co-ordinate which is off the screen, an invalid
                  function call error (#6) results.

--------------------------------------------------------------------------

    command:      DRAWWINDOW
    use:          DRAWWINDOW(Title$, XPos@%&, Pos@%&, Width@%&, Length@%&,
                    HeaderForeCol@%&, HeaderBackCol@%&, BorderForeCol@%&,
                    BodyCol@%&)
    description:  Draws a text window at given co-ordinates.
    notes:        <Title> is a string which is displayed centred at the
                  top of the window.
                  <HeaderForeCol> and <HeaderBackCol> are the foreground
                  and background colours of the window header.
                  <BorderForeCol> is the colour of the border.
                  <BodyCol> is the colour (background) of the window
                  text area.
                  See WDEMO.MOO for an example of how to use DRAWWINDOW.

--------------------------------------------------------------------------

    command:      GOTO
    use:          GOTO <label>
    description:  Jumps unconditionally to the specified label.
    notes:        Labels are alphanumeric, and have a colon ':' as a
                  suffix.
                  You should not use GOTO in to or out of a SUB, or
                  between two SUBs.
    example:
                    print "One"
                    goto fred
                    print "Two"
                    ' above line is never executed
                  fred:
                    print "Three"

--------------------------------------------------------------------------

    command:      SCREENSAVE
                  SCREENRESTORE
    use:          SCREENSAVE
                  SCREENRESTORE
    description:  Saves and restores current screen to and from the
                  screen "stack".
    notes:        The stack is a private buffer area maintained by these
                  commands, and is not related to the processor stack
                  (see the "STACK" directive).
                  A saved 80x25 screen consumes 4,000 bytes of far
                  memory; this is freed when the screen is restored.
                  Up to 16 screens may be placed on the stack; if too
                  many saves or restores are attempted, an invalid
                  function call runtime error will result.
                  It is important that a screensave has a matching
                  screenrestore elsewhere in the program flow.

--------------------------------------------------------------------------

    function:     XPOS
                  YPOS
    use:          XPOS
                  YPOS
    description:  Returns current X co-ordinate (XPOS) or Y co-ordinate
                  (YPOS) of the text cursor.
    example:
                  xsave% = xpos   ' save X co-ord to variable xsave%
                  ysave% = ypos   ' save Y co-ord to variable ysave%

--------------------------------------------------------------------------

    function:     GETSCREENSEG
    use:          GETSCREENSEG
    description:  Returns the current screen buffer segment.
    notes:        At runtime initialisation the screen buffer will
                  usually be either B000h (monochrome adapters) or B800h
                  (colour adapters). Under DESQview this value may
                  differ.
                  This function, along with the setscreenseg command,
                  can be used to implement double buffering for
                  flicker-free screen updates.
                  Can only be used with the _tty_str_direct driver.
    example:
                  screen_seg% = getscreenseg
                  print "Screen buffer is located at "
                  print hex16(screen_seg%) + ":0000\n"


--------------------------------------------------------------------------

    command:      SETSCREENSEG
    use:          SETSCREENSEG(seg%)
    description:  Sets the current screen buffer segment
    notes:        This command tells the _tty_str_direct driver to use
                  another area of memory as the screen segment.
                  This command, in conjunction with the getscreenseg
                  command, can be used to implement double buffering for
                  flicker-free screen updates.
                  It is not necessary to restore the original screen
                  buffer segment before termination of the program.
                  This is an advanced function and should be used with
                  care!
    example:
                  See WDEMO.MOO for an example of double buffering; when
                  compiled with the !SMOOTH define it will use double
                  buffering.

--------------------------------------------------------------------------

    function:     FREESTACK
    use:          variable% = FREESTACK
    description:  Returns the amount of free stack space in bytes.
    notes:        See also UNUSEDSTACK.

--------------------------------------------------------------------------

    function:     UNUSEDSTACK
    use:          variable% = UNUSEDSTACK
    description:  Returns the amount of unused stack space in bytes.
    notes:        The amount of unused stack space is the amount that
                  has never been used, in other words, the minimum
                  amount of stack space available in the most stack
                  hungry part of the program.
                  This function is useful for debugging and can show
                  when the size of the stack (STACK parameter in BEGIN
                  DEF area) may need to be increased.

--------------------------------------------------------------------------

    command:      MEMCOPY
    use:          MEMCOPY(src_offset%, dest_offset%, bytes%)
    description:  Copies memory in MoonRock data segment from source to
                  destination.
    notes:        <bytes> is the number of bytes to copy, and can be
                  between 1 and 65535.
                  This is a NEAR copy.
                  When compiled with the debug (/D) option, checking is
                  performed to ensure that a segment overrun (processor
                  exception #13) does not occur.
    example:

                  a$ = "Hello"   ' source
                  b$ = "     "   ' destination
                  print "b$ = '" + b$ + "'\n"
                  memcopy(strptr(a$), strptr(b$), 7) ' a$ -> b$
                  print "b$ = '" + b$ + "'\n"

--------------------------------------------------------------------------

    command:      FARMEMCOPY
    use:          FARMEMCOPY(src_seg%, src_offset%, dest_seg%,
                    dest_offset%, bytes%)
    description:  Copies memory between far segments.
    notes:        The source and destination segment may be the same.
                  <bytes> is the number of bytes to copy, and can be
                  between 1 and 65535.
                  When compiled with the debug (/D) option, checking is
                  performed to ensure that a segment overrun (processor
                  exception #13) does not occur.

--------------------------------------------------------------------------

    command:      FARMEMCOPYS
    use:          FARMEMCOPYS(src_seg%, dest_seg%, bytes%)
    description:  Copies memory between far segments, offset assumed to
                  be 0.
    notes:        This is slightly faster and produces smaller code than
                  FARMEMCOPY. Use this command if copying from and to
                  whole segments (seg:0000).
                  <bytes> is the number of bytes to copy, and can be
                  between 1 and 65535.

--------------------------------------------------------------------------

    command:      MEMFARTONEAR
    use:          MEMFARTONEAR(src_seg%, src_offset%, dest_offset%,
                    bytes%)
    description:  Copies memory from a far segment to MoonRock's data
                  segment.
    notes:        <bytes> is the number of bytes to copy, and can be
                  between 1 and 65535.
                  When compiled with the debug (/D) option, checking is
                  performed to ensure that a segment overrun (processor
                  exception #13) does not occur.

--------------------------------------------------------------------------

    command:      MEMNEARTOFAR
    use:          MEMNEARTOFAR(src_offset%, dest_seg%, dest_offset%,
                    bytes%)
    description:  Copies memory from MoonRock's data segment to a far
                  segment.
    notes:        <bytes> is the number of bytes to copy, and can be
                  between 1 and 65535.
                  When compiled with the debug (/D) option, checking is
                  performed to ensure that a segment overrun (processor
                  exception #13) does not occur.

--------------------------------------------------------------------------

    command:      RANDOMIZE
    use:          RANDOMIZE (value&)
    description:  Seeds the random number generator
    notes:        <value> is a doubleword between -2,147,483,648 and
                  +2,147,483,647; if it is 0, then the tick timer will
                  be used to seed the generator.

--------------------------------------------------------------------------

    function:     KEYSTATUS
    use:          variable@%& = KEYSTATUS (value@%&)
    description:  Returns the status of the specified key. If it is
                  currently down, TRUE (-1) will be returned, otherwise
                  FALSE (0) will be returned.
    notes:        This function is able to track several simultaneous
                  keypresses, including non character keys such as
                  shift/alt/ctrl.
                  This does not alter the keyboard buffer in any way;
                  inkey must be used to clear any unwanted keys.

                          KEYBOARD SCAN TABLE
             (with thanks to Ralf Brown's interrupt list)

        01h    Esc              31h    N
        02h    1 !              32h    M
        03h    2 @              33h    , <              63h    F16
        04h    3 #              34h    . >              64h    F17
        05h    4 $              35h    / ?              65h    F18
        06h    5 %              36h    Right Shift      66h    F19
        07h    6 ^              37h    Grey*            67h    F20
        08h    7 &              38h    Alt              68h    F21
        09h    8 *              39h    SpaceBar         69h    F22
        0Ah    9 (              3Ah    CapsLock         6Ah    F23
        0Bh    0 )              3Bh    F1               6Bh    F24
        0Ch    - _              3Ch    F2               6Ch    --
        0Dh    = +              3Dh    F3               6Dh    EraseEOF
        0Eh    Backspace        3Eh    F4
        0Fh    Tab              3Fh    F5               6Fh    Copy/Play
        10h    Q                40h    F6
        11h    W                41h    F7
        12h    E                42h    F8               72h    CrSel
        13h    R                43h    F9               73h    <delta> [*]
        14h    T                44h    F10              74h    ExSel
        15h    Y                45h    NumLock          75h    --
        16h    U                46h    ScrollLock       76h    Clear
        17h    I                47h    Home
        18h    O                48h    UpArrow
        19h    P                49h    PgUp
        1Ah    [ {              4Ah    Grey-
        1Bh    ] }              4Bh    LeftArrow
        1Ch    Enter            4Ch    Keypad 5
        1Dh    Ctrl             4Dh    RightArrow
        1Eh    A                4Eh    Grey+
        1Fh    S                4Fh    End
        20h    D                50h    DownArrow
        21h    F                51h    PgDn
        22h    G                52h    Ins
        23h    H                53h    Del
        24h    J                54h    SysReq
        25h    K
        26h    L                56h    left \| (102-key)
        27h    ; :              57h    F11
        28h    ' "              58h    F12
        29h    ` ~
        2Ah    Left Shift       5Ah    PA1
        2Bh    \ |              5Bh    F13 (LWin)
        2Ch    Z                5Ch    F14 (RWin)
        2Dh    X                5Dh    F15 (Menu)
        2Eh    C
        2Fh    V
        30h    B

    example:
                  while k% <> 27
                    if keystatus(1Eh) = TRUE then print "A is down!\n"
                    k% = inkey  ' clear buffer and also check for ESC
                  wend

--------------------------------------------------------------------------

    directive:    #IFDEF
    use:          #IFDEF <conditional def>
    description:  Begins a block of conditionally compiled code. If the
                  string <conditional def> is defined on the
                  commandline, then all code up to the next #ENDIF will
                  be compiled. To define conditional directives on the
                  commandline, specify them preceded with a "!" symbol,
                  eg:

                          MRC myprog !NOSAVE

    notes:        At this stage, #IFDEFs and #IFNDEFs cannot be nested.
                  No #ELSE directive exists.

--------------------------------------------------------------------------

    directive:    #IFNDEF
    use:          #IFNDEF <conditional def>
    description:  Begins a block of conditionally compiled code. If the
                  string <conditional def> is *NOT* defined on the
                  commandline, then all code up to the next #ENDIF will
                  be compiled. To define conditional directives on the
                  commandline, specify them preceded with a "!" symbol,
                  eg:

                          MRC myprog !NOSAVE

    notes:        At this stage, #IFDEFs and #IFNDEFs cannot be nested.
                  No #ELSE directive exists.

--------------------------------------------------------------------------

    directive:    #ENDIF
    use:          #ENDIF
    description:  Ends a block of conditionally compiled code.

--------------------------------------------------------------------------

    directive:    #INCLUDE
    use:          #INCLUDE <filename>
    description:  Includes the specified file as if it was part of the
                  current source file.
                  This can be used for source which is duplicated over
                  several files, or common constants and definitions.
                  This command is also available from the DEF area.
                  See the "Commands in DEF area" section for more detail
                  on #INCLUDE.

--------------------------------------------------------------------------

    directive:    #OUT
    use:          #OUT <string>
    description:  Prints the specified string to the screen during compile.
    notes:        This can be used to display the status of the compile
                  due to various #IFDEFs and #IFNDEFs.

--------------------------------------------------------------------------

    directive:    #ABORT
    use:          #ABORT
    description:  Immediately aborts the compile.
    notes:        Can be used when an invalid combination of #IFDEFs and
                  #IFNDEFs is selected.

--------------------------------------------------------------------------

    directive:    SUB
    use:          SUB <name> [ <parm1> [ , <parm2> ... ] ]
    description:  Defines the beginning of a subroutine block.
    notes:        The subroutine must be previously defined in the DEF
                  area, with an identical parameter list.
    see also:     END SUB

--------------------------------------------------------------------------

    function:     ABS
    use:          ABS(variable@%&)
    description:  Returns the absolute (positive) value of a number.
    example:
                  a% = -1
                  b% = abs(a%)
                  print "The absolute value of " + a% + " is " + b%

--------------------------------------------------------------------------

    command:      FREADFAR
    use:          FREADFAR(handle@%&, dest_seg%, dest_offset%, bytes%)
    description:  Reads a block of data from a currently open file into
                  far memory.
    notes:        This is an advanced function, and should be used with
                  care!
    example:
                  ' Loads a text screen from file FOO.SCR
                  $outstream _tty_str_direct
                  handle% = fopen("foo.scr", readonly)
                  sseg% = getscreenseg
                  freadfar(handle%, sseg%, 0, 4000)
                  fclose(handle%)

--------------------------------------------------------------------------

    function:     ISLEAPYEAR
    use:          ISLEAPYEAR (year%&)
    description:  Returns TRUE (-1) if the specified year is a leap
                  year. Returns FALSE (0) if the specified year is not a
                  leap year.
    notes:        The following algorithm is used:
                          LeapYear if Year Mod 4 = 0
                               EXCEPT if Year Mod 100 = 0
                                      UNLESS Year Mod 400 = 0
    example:

                  cmd$ = cmdline
                  if cmd$ = "" then
                    print "Usage: " + mypath + " <year>\n"
                    end
                  endif
                  yy% = val(cmd$)
                  print str(yy%) + " is "
                  if isleapyear(yy%) = FALSE then print "not "
                  print "a leap year"

--------------------------------------------------------------------------

    function:     MOD
    use:          MOD value@%
    description:  Returns the remainder or modulus.
    notes:        This can be used to scale a number to within the range
                  1-n.
                  This function is not yet implemented for doublewords.
    example:
                  a% = 356
                  b% = a% mod 15   ' x = 11

--------------------------------------------------------------------------

    directive:    EXIT SUB
                  EXIT WHILE
                  EXIT FOR
                  EXIT SELECT
                  EXIT IF
    use:          EXIT SUB
                  EXIT WHILE
                  EXIT FOR
                  EXIT SELECT
                  EXIT IF
    description:  Prematurely exits a block of code.
    notes:        In all cases except EXIT SUB, execution will resume at
                  the statement following the one which ends that block
                  of code (such as WEND, NEXT, END SELECT, ENDIF).
                  EXIT SUB will resume execution at the statement
                  following the CALL.

--------------------------------------------------------------------------

    function:     FEOF
    use:          variable@%& = FEOF (handle@%&)
    description:  Checks if file pointer is at end of file.
    notes:        FEOF is most useful in conjunction with FINPUT, to
                  prevent a "Read past end of file" runtime error.
    example:
                  h% = fopen("c:/mr/mr-ref.doc", readonly)
                  a% = feof(h%)
                  while a% = FALSE
                    finput(h%, a$)
                    print a$ + "\n"
                    a% = feof(h%)
                  wend
                  fclose(h%)

--------------------------------------------------------------------------

    function:     MEMSETB
                  MEMSETW
                  FARMEMSETB
                  FARMEMSETW
    use:          MEMSETB (value@, offset%, count%)
                  MEMSETW (value%, offset%, count%)
                  FARMEMSETB (value@, segment%, offset%, count%)
                  FARMEMSETW (value%, segment%, offset%, count%)
    description:  Fills a block of memory to the specified value.
    notes:        MEMSETB and MEMSETW work on NEAR memory; FARMEMSETB
                  and FARMEMSETW work on FAR memory.
                  For MEMSETB and FARMEMSETB, <value> is a byte.
                  For MEMSETW and FARMEMSETW, <value> is a word.
                  <count> specifies how many bytes or words will be
                  filled.

--------------------------------------------------------------------------

    function:     MFOSINIT
    use:          MFOSINIT (comport@%&)
    description:  Initialise FOSSIL. Returns FOSSIL handle for
                  successful initialisation, -1 if an error occurred.
    notes:        The "M*" set of FOSSIL functions are similar to
                  MoonRock's other FOSSIL functions, but allow
                  simultaneous access to more than one port.
                  FOSSIL may be initialised for "local" use if the
                  comport specified is 0, any MoonRock multiple port
                  FOSSIL functions called thereafter will be ignored.
                  Note, this special local port number differs from the
                  single port FOSSIL function implementation!
                  It is important to realise the distinction between a
                  handle and a port. The port is only specified when
                  calling MFOSINIT; all further multiple port FOSSIL
                  functions use a handle. No assumptions should be made
                  about the handle returned, and how it relates to the
                  port number.
    example:
                  foshandle% = mfosinit(2)
                  if foshandle% = -1 then
                    print "Error initialising FOSSIL\n"
                    end
                  endif

--------------------------------------------------------------------------

    command:      MFOSDEINIT
    use:          MFOSDEINIT (handle@%&)
    description:  De-initialise FOSSIL for specified handle. Performs
                  orderly cleanup and shutdown of the communications
                  port. Should be used when operations on the
                  communications port are complete.
    notes:        The "M*" set of FOSSIL functions are similar to
                  MoonRock's other FOSSIL functions, but allow
                  simultaneous access to more than one port.
                  This command is ignored if the FOSSIL was initialised
                  to a "local" comport.

--------------------------------------------------------------------------

    command:      MFOSTX
    use:          MFOSTX(handle@%&, str$)
    description:  Transmit string to output.
    notes:        The "M*" set of FOSSIL functions are similar to
                  MoonRock's other FOSSIL functions, but allow
                  simultaneous access to more than one port.
                  If the output buffer is full, this function waits
                  until it empties before returning; while waiting
                  timeslices are relinquished (see "timeslice" command)
                  This command is ignored if the FOSSIL was initialised
                  to "local" comport.
    example:
                  mfostx(handle%, "This is a string")

--------------------------------------------------------------------------

    command:      MFOSFLUSH
    use:          MFOSFLUSH (handle@%&)
    description:  Flush output buffer.
    notes:        The "M*" set of FOSSIL functions are similar to
                  MoonRock's other FOSSIL functions, but allow
                  simultaneous access to more than one port.
                  Flushes the serial output buffer. Any data still
                  waiting to be transmitted is discarded.
                  This command is ignored if the FOSSIL was initialised
                  to "local" comport.

--------------------------------------------------------------------------

    function:     MFOSCARRIER
    use:          MFOSCARRIER (handle@%&)
    description:  Check for presence of carrier detect (CD)
    notes:        The "M*" set of FOSSIL functions are similar to
                  MoonRock's other FOSSIL functions, but allow
                  simultaneous access to more than one port.
                  Returns TRUE (-1) if carrier is present, FALSE (0) if
                  not.
                  Returns TRUE (-1) if the FOSSIL was initialised to a
                  "local" comport.
    example:
                  if mfoscarrier(handle%) = FALSE then print "Carrier lost!"

--------------------------------------------------------------------------

    function:     MFOSDATAWAITING
    use:          MFOSDATAWAITING (handle@%&)
    description:  Check for presence of data in the serial input buffer.
    notes:        The "M*" set of FOSSIL functions are similar to
                  MoonRock's other FOSSIL functions, but allow
                  simultaneous access to more than one port.
                  Returns TRUE (-1) if data is present, otherwise
                  returns FALSE (0).
                  Returns FALSE (0) if the FOSSIL was initialised to a
                  "local" comport.
    example:
                  if mfosdatawaiting(handle%) = TRUE then
                    k% = mfosgetchar(handle%)
                  endif

--------------------------------------------------------------------------

    function:     MFOSGETCHAR
    use:          MFOSGETCHAR (handle@%&)
    description:  Get character from serial port without waiting.
    notes:        The "M*" set of FOSSIL functions are similar to
                  MoonRock's other FOSSIL functions, but allow
                  simultaneous access to more than one port.
                  Returns -1 if no character is available.
                  Returns -1 if the FOSSIL was initialised to a "local"
                  comport.

--------------------------------------------------------------------------

    function:     CODEPTR
    use:          CODEPTR (<label>)
    description:  Returns the offset of a code label or SUB.
    notes:        The label must exist in the current source file.
                  This function can be used for setting interrupt
                  vectors.

--------------------------------------------------------------------------

    function:     CRC32
                  CRC32S
    use:          variable& = CRC32 (initcrc&, offset%, len%)
                  variable& = CRC32S (str$, initcrc&)
    description:  Returns the 32 bit Cyclic Redundancy Check of a near
                  block of memory (CRC32) or MoonRock string (CRC32S).

--------------------------------------------------------------------------

    function:     MALLOC
    use:          pointer~ = MALLOC (size%)
    description:  Allocates a block of NEAR memory. This memory can be
                  used by a pointer or struc.
    notes:        Allocated memory does not need to be freed before
                  termination of program, however it is recommended that
                  memory be freed if it is no longer being used to
                  maximise the efficiency of the memory manager.

--------------------------------------------------------------------------

    command:      MFREE
    use:          MFREE(pointer~)
    description:  Frees a block of previously allocated near memory.

--------------------------------------------------------------------------

    function:     PREMALLOC
    use:          return% = PREMALLOC (size%)
    description:  Checks to see if allocating a block of memory will
                  succeed, to prevent a runtime error, and for sanity
                  checks.
    notes:        Returns the size of the block (passed in size%) or 0
                  if the allocation will fail.

--------------------------------------------------------------------------

    function:     MSIZE
    use:          size% = MSIZE (pointer~)
    description:  Returns the size of a previously allocated memory
                  block.
    notes:        Returns -1 if the pointer is invalid.

--------------------------------------------------------------------------

    command:      MKDIR
                  RMDIR
                  CHDIR
    use:          MKDIR (dir$)
                  RMDIR (dir$)
                  CHDIR (dir$)
    description:  Creates, removes or changes the current working
                  directory.
    notes:        Care should be taken with RMDIR and CHDIR to ensure
                  that the directory actually exists.

--------------------------------------------------------------------------

    command:      FRENAME
    use:          FRENAME (oldname$, newname$)
    description:  Renames a file from oldname to newname.
    notes:        Care should be taken to ensure that the file already
                  exists.

--------------------------------------------------------------------------

    command:      INT86
                  INT86X
    use:          INT86 (interrupt%, sourcebundle^, destbundle^)
                  INT86X (interrupt%, sourcebundle^, destbundle^)
    description:  Performs a software interrupt, taking register values
                  from sourcebundle^ prior to the interrupt, and placing
                  the results into destbundle^ after the interrupt. The
                  same bundle may be used for both source and destination.
                  INT86 handles registers AX, BX, CX, DX, BP, SI, DI,
                  and flags (bit mapped). INT86X handles all the
                  registers of INT86 and adds on DS and ES.
    notes:        This is an advanced function and can quite easily
                  crash your computer if you get one of the parameters
                  wrong.
    example:
                  int86 (21h, reg^, reg^)

--------------------------------------------------------------------------

         *** PLEASE ALSO SEE READ.ME FOR FURTHER REFERENCE ***

=== END OF REFERENCE ===

